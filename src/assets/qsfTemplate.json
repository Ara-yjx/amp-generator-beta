{
  "SurveyEntry": {
    "SurveyID": "SV_dnAkDKOddKsPTpQ",
    "SurveyName": "SPT",
    "SurveyDescription": null,
    "SurveyOwnerID": "UR_8qrlYLU2jfq7Cqa",
    "SurveyBrandID": "upenn",
    "DivisionID": null,
    "SurveyLanguage": "EN",
    "SurveyActiveResponseSet": "RS_6zXdxkXXWoWLKL4",
    "SurveyStatus": "Active",
    "SurveyStartDate": "0000-00-00 00:00:00",
    "SurveyExpirationDate": "0000-00-00 00:00:00",
    "SurveyCreationDate": "2023-07-08 05:22:35",
    "CreatorID": "UR_8qrlYLU2jfq7Cqa",
    "LastModified": "2024-11-30 22:32:06",
    "LastAccessed": "0000-00-00 00:00:00",
    "LastActivated": "2023-09-09 05:47:48",
    "Deleted": null
  },
  "SurveyElements": [
    {
      "SurveyID": "SV_dnAkDKOddKsPTpQ",
      "Element": "BL",
      "PrimaryAttribute": "Survey Blocks",
      "SecondaryAttribute": null,
      "TertiaryAttribute": null,
      "Payload": [
        {
          "Type": "Default",
          "Description": "Load parameters",
          "ID": "BL_cJgbZWbXtlZwIQe",
          "BlockElements": [
            {
              "Type": "Question",
              "QuestionID": "QID1"
            }
          ]
        },
        {
          "Type": "Trash",
          "Description": "Trash \/ Unused Questions",
          "ID": "BL_3FesUeo9uvib7y6",
          "BlockElements": [],
          "Options": {
            "BlockLocking": "false",
            "RandomizeQuestions": "false",
            "BlockVisibility": "Expanded"
          }
        },
        {
          "Type": "Standard",
          "SubType": "",
          "Description": "Run trials",
          "ID": "BL_3EDLHCLtBlrl7oO",
          "BlockElements": [
            {
              "Type": "Question",
              "QuestionID": "QID2"
            }
          ]
        }
      ]
    },
    {
      "SurveyID": "SV_dnAkDKOddKsPTpQ",
      "Element": "FL",
      "PrimaryAttribute": "Survey Flow",
      "SecondaryAttribute": null,
      "TertiaryAttribute": null,
      "Payload": {
        "Type": "Root",
        "FlowID": "FL_1",
        "Flow": [
          {
            "Type": "EmbeddedData",
            "FlowID": "FL_7",
            "EmbeddedData": [
              {
                "Description": "stimuliItems",
                "Type": "Custom",
                "Field": "stimuliItems",
                "VariableType": "String",
                "DataVisibility": [],
                "AnalyzeText": false,
                "Value": "[{\n  \"pools\": [\n    {\n      \"items\": [{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_zANlu6B1UFbcflF\",\"count\":5},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_vQzlOEGBXbnuhSn\",\"count\":5},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_XJw0GZWrbUlfyOI\",\"count\":5},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_E72k4fxbh7Zxw7e\",\"count\":5},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_RFsC6tV9IGidru4\",\"count\":5},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_M4wae3Z0GjWQRkD\",\"count\":5},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_F9fpRim5SiLGU8t\",\"count\":5},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_xLUoASyb57j7ezR\",\"count\":5}],\n      \"shuffle\": 2\n    },\n    {\n      \"items\": [{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_3jUT9yhSx8mI5wy\",\"count\":\"1\"},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_25WNyckTIXiv4bQ\",\"count\":\"1\"},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_9HRiGBCgN50xZI2\",\"count\":\"1\"},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_bqP6msi7K3SPhPM\",\"count\":\"1\"},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_8q8uD7MVCDyWdzo\",\"count\":\"1\"},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_5jy9Uo2ZV2BaPki\",\"count\":\"1\"},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_3KIqzYFkmmCv3cq\",\"count\":\"1\"},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_2lYARTfPvNPiwF8\",\"count\":\"1\"},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_8CagBSGuqa3103k\",\"count\":\"1\"},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_eXWu2juJ3IFpiia\",\"count\":\"1\"},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_9t0w55KTUPY9uK2\",\"count\":\"1\"},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_5jo1Wq1EpYoas3s\",\"count\":\"1\"},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_81blvWQpZDlael8\",\"count\":\"1\"},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_0U7PxswipvQuNrU\",\"count\":\"1\"},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_2gZtO50zqBd39B4\",\"count\":\"1\"},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_2aQYOy04gO7kx4G\",\"count\":\"1\"},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_9yt21bg0o84Tt9c\",\"count\":\"1\"},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_03srJoTDehJb2V8\",\"count\":\"1\"},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_4YIfcyT8d1xghlI\",\"count\":\"1\"},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_8qUdZ0CwAXeCKxM\",\"count\":\"1\"},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_6QCRchjKW1dGhcG\",\"count\":\"1\"},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_4HLhYK2seAX1opw\",\"count\":\"1\"},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_2gF10eQOSwdHxfo\",\"count\":\"1\"},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_8qucEPy2K0oFkWy\",\"count\":\"1\"},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_2tULPzYl2dk6eiO\",\"count\":\"1\"},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_3r3a5Z2Ruguka7s\",\"count\":\"1\"},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_3en7w39WHobUvoW\",\"count\":\"1\"},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_abX7fBDnVzvPSjc\",\"count\":\"1\"},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_dnUHxQckvLbEV4a\",\"count\":\"1\"},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_agwjmD9fGQMcawK\",\"count\":\"1\"},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_3OjfkCyc7ZmCBym\",\"count\":\"1\"},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_eP6i52QjuzksfRA\",\"count\":\"1\"},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_1HeeVDSoYiQspE2\",\"count\":\"1\"},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_7X1IdJXN98qbVhI\",\"count\":\"1\"},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_e8rwUgorjxXXSuy\",\"count\":\"1\"},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_9poogxcVq9oAkQe\",\"count\":\"1\"},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_d73fKrvvmZqxFn8\",\"count\":\"1\"},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_8ogT3ozEpraFUto\",\"count\":\"1\"},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_0roC8vKyNFfu8wS\",\"count\":\"1\"},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_bIb0xXbDx6JVL5Y\",\"count\":\"1\"},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_3QxQYuy313umdmu\",\"count\":\"1\"},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_e3F1LOHphmo0w98\",\"count\":\"1\"},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_8kwWckkggPMtpWe\",\"count\":\"1\"},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_0MoXFM69zQnFxEq\",\"count\":\"1\"},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_0pkHgkE3ck2IaOO\",\"count\":\"1\"},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_2f0J3X3u1gVwoBg\",\"count\":\"1\"},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_b88sQUZ7HZURpdQ\",\"count\":\"1\"},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_cN0xpyB0oYo4rVs\",\"count\":\"1\"},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_9vk06qTobnmwRlc\",\"count\":\"1\"},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_1ZIuviqhK3uETBA\",\"count\":\"1\"},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_ePDdYlUD7iHUx7g\",\"count\":\"1\"},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_eRJnNWh2BpJfv5c\",\"count\":\"1\"},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_0GSkjfufXlNmYpU\",\"count\":\"1\"},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_afpeLjDOMD1i3Hw\",\"count\":\"1\"},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_6Lm9B6qm4EgmO0u\",\"count\":\"1\"},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_82s7sXnHN1InklE\",\"count\":\"1\"},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_6thdUpsXpgOQefs\",\"count\":\"1\"},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_0SzgDcIaL7N8EZw\",\"count\":\"1\"},{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/ControlPanel\/Graphic.php?IM=IM_8I0kGbUUJ1U3HRI\",\"count\":\"1\"}],\n      \"shuffle\": true\n    },\n    {\n      \"items\": [{\"type\":\"image\",\"content\":\"https:\/\/upenn.co1.qualtrics.com\/CP\/Graphic.php?IM=IM_bQlal1oB5kyb60m\",\"count\":\"40\"}],\n      \"shuffle\": false\n    }\n  ],\n  \"totalTrials\": 10\n}]"
              },
              {
                "Description": "totalRounds",
                "Type": "Custom",
                "Field": "totalRounds",
                "VariableType": "String",
                "DataVisibility": [],
                "AnalyzeText": false,
                "Value": "2"
              },
              {
                "Description": "timeline",
                "Type": "Custom",
                "Field": "timeline",
                "VariableType": "String",
                "DataVisibility": [],
                "AnalyzeText": false,
                "Value": "{\n\"advanced\": true,\n\"pages\":\n[{\n  \"displays\": { \"A1\": [\"pool\", [1]], \"A2\": [\"pool\", [1]] },\n  \"response\": {\"keyboard\": {\"keys\": [\"d\", \"k\"]}}\n}, {\n  \"condition\": [\"response\", 1, \"==\", [\"d\"]],\n  \"displays\": { \"A1\": [\"copy\", 1, \"A1\"], \"A2\": [\"copy\", 1, \"A2\"], \"B1\": [\"pool\", [2]] },\n  \"response\": {\"keyboard\": {\"keys\": [\"Space\"]}}\n}, {\n  \"condition\": [\"response\", 1, \"==\", [\"k\"]],\n  \"displays\": { \"A1\": [\"copy\", 1, \"A1\"], \"A2\": [\"copy\", 1, \"A2\"], \"B1\": [\"pool\", [3]] },\n  \"response\": {\"keyboard\": {\"keys\": [\"d\"]}}\n}, {\n  \"condition\": [\"response\", 3, \"==\", [\"d\"]],\n  \"displays\": { \"A1\": [\"copy\", 1, \"A1\"], \"A2\": [\"copy\", 1, \"A2\"], \"B1\": [\"pool\", [2]] },\n  \"response\": {\"keyboard\": {\"keys\": [\"Space\"]}}\n}]\n}"
              },
              {
                "Description": "primes",
                "Type": "Custom",
                "Field": "primes",
                "VariableType": "String",
                "DataVisibility": [],
                "AnalyzeText": false,
                "Value": "[\n  { \"name\": \"learned_1\", \"pool\":1, \"include\": [1], \"overrideCount\": [20, null] },\n  { \"name\": \"control_1\", \"pool\": 1, \"include\": [1,2], \"exclude\": [\"learned_1\"], \"overrideCount\": 6 }\n]"
              },
              {
                "Description": "acceptedKeys",
                "Type": "Custom",
                "Field": "acceptedKeys",
                "VariableType": "String",
                "DataVisibility": [],
                "AnalyzeText": false,
                "Value": "d,k,Space"
              },
              {
                "Description": "darkMode",
                "Type": "Custom",
                "Field": "darkMode",
                "VariableType": "String",
                "DataVisibility": [],
                "AnalyzeText": false,
                "Value": "false"
              }
            ]
          },
          {
            "Type": "EmbeddedData",
            "FlowID": "FL_8",
            "EmbeddedData": [
              {
                "Description": "sptResponses",
                "Type": "Recipient",
                "Field": "sptResponses",
                "VariableType": "String",
                "DataVisibility": [],
                "AnalyzeText": false
              },
              {
                "Description": "sptResponsesUnreversed",
                "Type": "Recipient",
                "Field": "sptResponsesUnreversed",
                "VariableType": "String",
                "DataVisibility": [],
                "AnalyzeText": false
              },
              {
                "Description": "sptResponseDurations",
                "Type": "Recipient",
                "Field": "sptResponseDurations",
                "VariableType": "String",
                "DataVisibility": [],
                "AnalyzeText": false
              },
              {
                "Description": "sptResponsesArray",
                "Type": "Recipient",
                "Field": "sptResponsesArray",
                "VariableType": "String",
                "DataVisibility": [],
                "AnalyzeText": false
              },
              {
                "Description": "sptResponsesUnreversedArray",
                "Type": "Recipient",
                "Field": "sptResponsesUnreversedArray",
                "VariableType": "String",
                "DataVisibility": [],
                "AnalyzeText": false
              },
              {
                "Description": "sptResponseDurationsArray",
                "Type": "Recipient",
                "Field": "sptResponseDurationsArray",
                "VariableType": "String",
                "DataVisibility": [],
                "AnalyzeText": false
              },
              {
                "Description": "shuffleResult",
                "Type": "Recipient",
                "Field": "shuffleResult",
                "VariableType": "String",
                "DataVisibility": [],
                "AnalyzeText": false
              },
              {
                "Description": "primeResult",
                "Type": "Recipient",
                "Field": "primeResult",
                "VariableType": "String",
                "DataVisibility": [],
                "AnalyzeText": false
              }
            ]
          },
          {
            "Type": "Block",
            "ID": "BL_cJgbZWbXtlZwIQe",
            "FlowID": "FL_2",
            "Autofill": []
          },
          {
            "Type": "Standard",
            "ID": "BL_3EDLHCLtBlrl7oO",
            "FlowID": "FL_5",
            "Autofill": []
          }
        ],
        "Properties": {
          "Count": 9
        }
      }
    },
    {
      "SurveyID": "SV_dnAkDKOddKsPTpQ",
      "Element": "PL",
      "PrimaryAttribute": "Preview Link",
      "SecondaryAttribute": null,
      "TertiaryAttribute": null,
      "Payload": {
        "PreviewType": "Brand",
        "PreviewID": "6115033c-b61a-4566-9c05-d218626bb355"
      }
    },
    {
      "SurveyID": "SV_dnAkDKOddKsPTpQ",
      "Element": "SO",
      "PrimaryAttribute": "Survey Options",
      "SecondaryAttribute": null,
      "TertiaryAttribute": null,
      "Payload": {
        "BackButton": "false",
        "SaveAndContinue": "true",
        "SurveyProtection": "PublicSurvey",
        "BallotBoxStuffingPrevention": "false",
        "NoIndex": "Yes",
        "SecureResponseFiles": "true",
        "SurveyExpiration": "None",
        "SurveyTermination": "DefaultMessage",
        "Header": "",
        "Footer": "",
        "ProgressBarDisplay": "None",
        "PartialData": "+1 week",
        "ValidationMessage": "",
        "PreviousButton": " \u2190 ",
        "NextButton": " \u2192 ",
        "SurveyTitle": "Qualtrics Survey | Qualtrics Experience Management",
        "SkinLibrary": "upenn",
        "SkinType": "templated",
        "Skin": {
          "brandingId": null,
          "templateId": "*base",
          "overrides": null
        },
        "NewScoring": 1,
        "SurveyMetaDescription": "The most powerful, simple and trusted way to gather experience data. Start your journey to experience management and try a free account today.",
        "SurveyName": "SPT",
        "CustomStyles": [],
        "ProtectSelectionIds": true
      }
    },
    {
      "SurveyID": "SV_dnAkDKOddKsPTpQ",
      "Element": "QGO",
      "PrimaryAttribute": "QGO_QuotaGroupOrder",
      "SecondaryAttribute": null,
      "TertiaryAttribute": null,
      "Payload": [
        "QG_FH8Cdf0L5gg9uBa"
      ]
    },
    {
      "SurveyID": "SV_dnAkDKOddKsPTpQ",
      "Element": "SCO",
      "PrimaryAttribute": "Scoring",
      "SecondaryAttribute": null,
      "TertiaryAttribute": null,
      "Payload": {
        "ScoringCategories": [],
        "ScoringCategoryGroups": [],
        "ScoringSummaryCategory": null,
        "ScoringSummaryAfterQuestions": 0,
        "ScoringSummaryAfterSurvey": 0,
        "DefaultScoringCategory": null,
        "AutoScoringCategory": null
      }
    },
    {
      "SurveyID": "SV_dnAkDKOddKsPTpQ",
      "Element": "PROJ",
      "PrimaryAttribute": "CORE",
      "SecondaryAttribute": null,
      "TertiaryAttribute": "1.1.0",
      "Payload": {
        "ProjectCategory": "CORE",
        "SchemaVersion": "1.1.0"
      }
    },
    {
      "SurveyID": "SV_dnAkDKOddKsPTpQ",
      "Element": "STAT",
      "PrimaryAttribute": "Survey Statistics",
      "SecondaryAttribute": null,
      "TertiaryAttribute": null,
      "Payload": {
        "MobileCompatible": true,
        "ID": "Survey Statistics"
      }
    },
    {
      "SurveyID": "SV_dnAkDKOddKsPTpQ",
      "Element": "QC",
      "PrimaryAttribute": "Survey Question Count",
      "SecondaryAttribute": "5",
      "TertiaryAttribute": null,
      "Payload": null
    },
    {
      "SurveyID": "SV_dnAkDKOddKsPTpQ",
      "Element": "SQ",
      "PrimaryAttribute": "QID2",
      "SecondaryAttribute": "d key = less pleasant : k key = more pleasant",
      "TertiaryAttribute": null,
      "Payload": {
        "QuestionText": "\n<div class=\"spt-trial-container\" style=\"height: 800px; box-sizing: content-box; padding-top: 0px;\">\n<div class=\"spt-trial-container-inner\" style=\"display: flex; flex-direction: column; margin-top: -100px;\">\n  \n  <div style=\"display: flex; justify-content: center; align-items: center; margin-top: 100px; margin-left: -100px;\">\n    \n    <div class=\"spt-trial-content spt-trial-content-A1\" style=\"margin-left: 100px; width: 300px; height: 300px; position: relative; display: flex; justify-content: center; align-items: center; text-align: center; \">\n      <img class=\"spt-trial-image\" style=\"width: 100%; height: 100% !important; object-fit: contain; display: none;\"\/>\n      <div class=\"spt-trial-text\" style=\"width: 100%; height: 100%; white-space: pre-line; overflow-wrap: break-word; color: #000; font-weight: bold; font-size: 28px; line-height: 1.5em; display: none;\"><\/div>\n      <div class=\"spt-trial-button\" style=\"max-width: 100%; white-space: pre-line; overflow-wrap: break-word; color: #000; font-size: 20px; line-height: 1.2em; border: 1px solid #000; border-radius: 4px; background-color: #f3f3f3; padding: 0 4px; cursor: pointer; display: none;\" onmouseenter=\"this.style.boxShadow='0 0 4px 0 #ccc'\" onmouseleave=\"this.style.boxShadow=''\"><\/div>\n      <div class=\"spt-trial-accurate-point\" style=\"position: absolute; bottom: -30px; width: 15px; height: 15px; border: 1px solid #000; border-radius: 50%; background-color: #f3f3f3; display: none;\" onmouseenter=\"this.style.boxShadow='0 0 4px 0 #ccc'\" onmouseleave=\"this.style.boxShadow=''\"><\/div>\n    <\/div>\n    \n    <div class=\"spt-trial-content spt-trial-content-A2\" style=\"margin-left: 100px; width: 300px; height: 300px; position: relative; display: flex; justify-content: center; align-items: center; text-align: center; \">\n      <img class=\"spt-trial-image\" style=\"width: 100%; height: 100% !important; object-fit: contain; display: none;\"\/>\n      <div class=\"spt-trial-text\" style=\"width: 100%; height: 100%; white-space: pre-line; overflow-wrap: break-word; color: #000; font-weight: bold; font-size: 28px; line-height: 1.5em; display: none;\"><\/div>\n      <div class=\"spt-trial-button\" style=\"max-width: 100%; white-space: pre-line; overflow-wrap: break-word; color: #000; font-size: 20px; line-height: 1.2em; border: 1px solid #000; border-radius: 4px; background-color: #f3f3f3; padding: 0 4px; cursor: pointer; display: none;\" onmouseenter=\"this.style.boxShadow='0 0 4px 0 #ccc'\" onmouseleave=\"this.style.boxShadow=''\"><\/div>\n      <div class=\"spt-trial-accurate-point\" style=\"position: absolute; bottom: -30px; width: 15px; height: 15px; border: 1px solid #000; border-radius: 50%; background-color: #f3f3f3; display: none;\" onmouseenter=\"this.style.boxShadow='0 0 4px 0 #ccc'\" onmouseleave=\"this.style.boxShadow=''\"><\/div>\n    <\/div>\n  <\/div>\n  \n  <div style=\"display: flex; justify-content: center; align-items: center; margin-top: 100px; margin-left: -100px;\">\n    \n    <div class=\"spt-trial-content spt-trial-content-B1\" style=\"margin-left: 100px; width: 300px; height: 300px; position: relative; display: flex; justify-content: center; align-items: center; text-align: center; \">\n      <img class=\"spt-trial-image\" style=\"width: 100%; height: 100% !important; object-fit: contain; display: none;\"\/>\n      <div class=\"spt-trial-text\" style=\"width: 100%; height: 100%; white-space: pre-line; overflow-wrap: break-word; color: #000; font-weight: bold; font-size: 28px; line-height: 1.5em; display: none;\"><\/div>\n      <div class=\"spt-trial-button\" style=\"max-width: 100%; white-space: pre-line; overflow-wrap: break-word; color: #000; font-size: 20px; line-height: 1.2em; border: 1px solid #000; border-radius: 4px; background-color: #f3f3f3; padding: 0 4px; cursor: pointer; display: none;\" onmouseenter=\"this.style.boxShadow='0 0 4px 0 #ccc'\" onmouseleave=\"this.style.boxShadow=''\"><\/div>\n      <div class=\"spt-trial-accurate-point\" style=\"position: absolute; bottom: -30px; width: 15px; height: 15px; border: 1px solid #000; border-radius: 50%; background-color: #f3f3f3; display: none;\" onmouseenter=\"this.style.boxShadow='0 0 4px 0 #ccc'\" onmouseleave=\"this.style.boxShadow=''\"><\/div>\n    <\/div>\n    \n    <div class=\"spt-trial-content spt-trial-content-B2\" style=\"margin-left: 100px; width: 300px; height: 300px; position: relative; display: flex; justify-content: center; align-items: center; text-align: center; \">\n      <img class=\"spt-trial-image\" style=\"width: 100%; height: 100% !important; object-fit: contain; display: none;\"\/>\n      <div class=\"spt-trial-text\" style=\"width: 100%; height: 100%; white-space: pre-line; overflow-wrap: break-word; color: #000; font-weight: bold; font-size: 28px; line-height: 1.5em; display: none;\"><\/div>\n      <div class=\"spt-trial-button\" style=\"max-width: 100%; white-space: pre-line; overflow-wrap: break-word; color: #000; font-size: 20px; line-height: 1.2em; border: 1px solid #000; border-radius: 4px; background-color: #f3f3f3; padding: 0 4px; cursor: pointer; display: none;\" onmouseenter=\"this.style.boxShadow='0 0 4px 0 #ccc'\" onmouseleave=\"this.style.boxShadow=''\"><\/div>\n      <div class=\"spt-trial-accurate-point\" style=\"position: absolute; bottom: -30px; width: 15px; height: 15px; border: 1px solid #000; border-radius: 50%; background-color: #f3f3f3; display: none;\" onmouseenter=\"this.style.boxShadow='0 0 4px 0 #ccc'\" onmouseleave=\"this.style.boxShadow=''\"><\/div>\n    <\/div>\n  <\/div>\n<\/div>\n<\/div>\n\n<div style=\"display: flex; justify-content: space-around; margin-top: 6em; white-space: pre-wrap; color: black; text-align: center\">d key = less pleasant        :        k key = more pleasant<\/div>\n",
        "DefaultChoices": false,
        "DataExportTag": "SPT",
        "QuestionType": "DB",
        "Selector": "TB",
        "Configuration": {
          "QuestionDescriptionOption": "UseText"
        },
        "QuestionDescription": "d key = less pleasant : k key = more pleasant",
        "ChoiceOrder": [],
        "Validation": {
          "Settings": {
            "Type": "None"
          }
        },
        "GradingData": [],
        "Language": [],
        "NextChoiceId": 4,
        "NextAnswerId": 1,
        "QuestionID": "QID2",
        "QuestionJS": "\/**\n * @typedef {import('.\/type.d.ts').StimuliItem} StimuliItem\n * @typedef {import('.\/type.d.ts').StimuliPrimeItem} StimuliPrimeItem\n * @typedef {import('.\/type.d.ts').StimuliPoolConfig} StimuliPoolConfig\n * @typedef {import('.\/type.d.ts').Params} Params\n * \n * @typedef {{type: 'image'|'text'|'button'|'empty', content: string}|null} StimuliItemToDisplay\n * @typedef {{params: Params, responses: number[][]|number[][][], responseDurations: number[][]|number[][][], responsePools: number[][]|number[][][]}} States\n *\/\nconst myGlobalThis = window.top;\nmyGlobalThis.qs = Qualtrics.SurveyEngine; \/\/ for debug\nconst sptSurveyIdentifier = Qualtrics.SurveyEngine.getEmbeddedData('sptSurveyIdentifier');\nconsole.log('[SPT] sptSurveyIdentifier: ' + sptSurveyIdentifier);\n\/** @type {States} *\/\nconst states = sptSurveyIdentifier ? myGlobalThis.sptStates[sptSurveyIdentifier] : myGlobalThis.sptStates;\nconsole.debug('Loaded states', states);\n\n\/**\n * One instance per document (iframe)\n *\/\nclass GlobalKeydownEventListener {\n  constructor(questionContainer) {\n    \/** @type {(key: string) -> void} *\/\n    this.questionContainer = questionContainer;\n    this.callback = undefined;\n    this.acceptedKeys = [];\n    this.handleKeyDown = this.handleKeyDown.bind(this);\n    this.handleMessage = this.handleMessage.bind(this);\n    this.passKeydownToTopWindow = this.passKeydownToTopWindow.bind(this);\n  }\n  mount() {\n    window.addEventListener('keydown', this.passKeydownToTopWindow);\n    window.top.addEventListener('keydown', this.handleKeyDown);\n    window.top.addEventListener('message', this.handleMessage);\n  }\n  unmount() {\n    window.removeEventListener('keydown', this.passKeydownToTopWindow);\n    window.top.removeEventListener('keydown', this.handleKeyDown);\n    window.top.removeEventListener('message', this.handleMessage);\n  }\n  handleKeyDown(event) {\n    const normalizedKey = this.normalizeKey(event.key);\n    if (this.callback && this.acceptedKeys.includes(normalizedKey)) {\n      event.stopPropagation();\n      event.preventDefault();\n      this.callback && this.callback(normalizedKey);\n    }\n  }\n  handleMessage(event) {\n    if (event.data.type === 'iframe-keydown') {\n      this.callback && this.callback(event.data.key);\n    }\n  }\n  \/**\n   * Pass keydown event from iframe to top window. \n   * Otherwise, in Qualtrics Preview, top window cannot receive keydown event if focus is on iframe\n   *\/\n  passKeydownToTopWindow(event) {\n    const normalizedKey = this.normalizeKey(event.key);\n    if (this.callback && this.acceptedKeys.includes(normalizedKey)) {\n      event.stopPropagation();\n      event.preventDefault();\n      window.top.postMessage({\n        type: 'iframe-keydown',\n        key: normalizedKey,\n      });\n    }\n  }\n  normalizeKey(key) {\n    \/\/ Maybe we should use `code` instead of `key` in the future\n    if (key.length === 1) {\n      if (key >= '0' && key <= '9') return key;\n      if (key >= 'a' && key <= 'z') return key;\n      if (key >= 'A' && key <= 'Z') return key.toLowerCase();\n      if (key === ' ') return 'Space';\n    }\n    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Enter'].includes(key)) {\n      return key;\n    }\n    return null;\n  }\n}\n\n\nclass GlobalMouseEventListener {\n  \/**\n   * @param {HTMLDivElement} questionContainer \n   *\/\n  constructor(questionContainer) {\n    \/** @type {(key: string) -> void} *\/\n    this.callback = undefined;\n    this.questionContainer = questionContainer;\n    this.removeListeners = [];\n    this.handleMessage = this.handleMessage.bind(this);\n  }\n  mount() {\n    window.top.addEventListener('message', this.handleMessage);\n  }\n  unmount() {\n    unlisten();\n    window.top.removeEventListener('message', this.handleMessage);\n  }\n  \/** @param {{key: string, isButton: boolean, accuratePoint?: boolean}[]} config *\/\n  listen(config) {\n    this.unlisten();\n    Object.entries(config).forEach(([key, { isButton, accuratePoint }]) => {\n      function postMessageOnClick(event) {\n        event.stopPropagation();\n        event.preventDefault();\n        window.top.postMessage({\n          type: 'iframe-click',\n          key,\n        });\n      }\n      let elQuery = '.spt-trial-content.spt-trial-content-' + key;\n      if (isButton) {\n        elQuery += ' .spt-trial-button';\n      } else if (accuratePoint) {\n        elQuery += ' .spt-trial-accurate-point';\n      }\n      const el = this.questionContainer.querySelector(elQuery);\n      if (el) {\n        el.addEventListener('click', postMessageOnClick);\n        this.removeListeners.push(function () { el.removeEventListener('click', postMessageOnClick) });\n      }\n    });\n  }\n  unlisten() {\n    this.removeListeners.forEach(x => x());\n    this.removeListeners = [];\n  }\n  handleMessage(event) {\n    if (event.data.type === 'iframe-click') {\n      this.callback && this.callback(event.data.key);\n    }\n  }\n}\n\n\n\/\/ Prepare input and output in states\nif (!states.params) {\n  alert('Sorry. Critical error occured in the survey webpage. Please restart survey or contact the survey conductor. Error message: \"SPT trial parameters not found.\"');\n}\nif (states.currentRound === undefined) {\n  states.currentRound = 0;\n}\n\n\/\/ Initialize response array\nif (states.responses === undefined) {\n  states.responses = generateEmptyReponseSlots();\n}\nif (states.responsesUnreversed === undefined) {\n  states.responsesUnreversed = generateEmptyReponseSlots();\n}\nif (states.responseDurations === undefined) {\n  states.responseDurations = generateEmptyReponseSlots();\n}\n\n\/\/ if (states.responsePools === undefined) {\n\/\/   states.responsePools = generateEmptyReponseSlots();\n\/\/ }\nfunction generateEmptyReponseSlots() {\n  return states.params.rounds.map(\n    ({ totalTrials, timeline, advancedTimeline }) => {\n      if (timeline) {\n        return Array(totalTrials);\n      } else if (advancedTimeline) {\n        return Array(totalTrials).fill().map(() => Array(advancedTimeline.pages.length));\n      }\n    }\n  );\n}\n\nconst roundIndex = states.currentRound;\nconst roundParams = states.params.rounds[roundIndex];\nif (!roundParams) {\n  alert('Sorry. Critical error occured in the survey webpage. Please restart survey or contact the survey conductor. Error message: \"SPT round parameters not found for round #' + (roundIndex + 1) + '.\"');\n}\n\n\nconst { pools, totalTrials, timeline, advancedTimeline } = roundParams;\n\n\nlet mouseTracker;\nif (advancedTimeline && advancedTimeline.pages.filter(p => p.mouseTracking).length) {\n  mouseTracker = MouseTracker();\n  Qualtrics.SurveyEngine.addOnload(mouseTracker.mount);\n  Qualtrics.SurveyEngine.addOnUnload(mouseTracker.unmount);\n}\n\n\nQualtrics.SurveyEngine.addOnload(function () {\n\n  const thisQultricsQuestion = this;\n  this.hideNextButton();\n  this.hidePreviousButton();\n  this.hideChoices();\n\n  const displayController = DisplayController(thisQultricsQuestion.questionContainer);\n  const keyboardListener = new GlobalKeydownEventListener(thisQultricsQuestion.questionContainer);\n  this.keyboardListener = keyboardListener;\n  keyboardListener.mount();\n  keyboardListener.acceptedKeys = states.params.acceptedKeys;\n  const mouseListener = new GlobalMouseEventListener(thisQultricsQuestion.questionContainer);\n  this.mouseListener = mouseListener;\n  mouseListener.mount();\n\n  const { currentRound } = states;\n  const poolUsage = pools.map(() => 0); \/\/ within this round\n\n  function runTrial(tid) {\n    if (timeline) runTimelineTrial(tid);\n    else if (advancedTimeline) runAdvancedTimeline(tid);\n  }\n\n  \/\/ Trial state machine:\n  \/\/ -> display stimuli[] -> retardation -> !!!await keyboard!!! --@accepted-> retention -> $\n  \/\/                                                             --@timeout?--------------> $ \n  function runTimelineTrial(tid) {\n    \/\/ The shared-variable communication between keyboard thread and timeout thread\n    \/\/ When one thread is resolved, set isAwaiting=false to disable the other thread\n    let isAwaiting = false;\n    let awaitKeyboardStartTime;\n\n    console.debug('runTimelineTrial', currentRound, tid);\n\n    timeline.concurrentDisplays.forEach((frame, frameIndex) => {\n      const stimuliItems = getStimuliItemsToDisplay(frame, poolUsage);\n      const frameStartTime = sum(timeline.durationsAndIntervals.slice(0, frameIndex).flat());\n      setTimeout(() => {\n        displayController.display(stimuliItems);\n      }, frameStartTime);\n      if (frameIndex !== timeline.concurrentDisplays.length - 1) {\n        \/\/ For non-last frame, hide this frame or await input\n        const stimuliDuration = timeline.durationsAndIntervals[frameIndex][0];\n        setTimeout(() => {\n          displayController.clear();\n        }, frameStartTime + stimuliDuration);\n      } else {\n        \/\/ start awaiting keyboard\n        setTimeout(() => {\n          isAwaiting = true;\n          keyboardListener.callback = keyboardListenerCallback;\n          awaitKeyboardStartTime = performance.now();\n        }, frameStartTime + (timeline.delayBeforeKeyboard || 0));\n        \/\/ auto proceed\n        if (timeline.autoProceedTimeout !== null && timeline.autoProceedTimeout >= 0) {\n          setTimeout(autoProceedCallback, frameStartTime + timeline.autoProceedTimeout);\n        }\n      }\n    });\n\n    function keyboardListenerCallback(key) {\n      if (!isAwaiting) return;\n      isAwaiting = false;\n      keyboardListener.callback = undefined;\n      const duration = Math.floor(performance.now() - awaitKeyboardStartTime);\n      states.responses[currentRound][tid] = key;\n      states.responseDurations[currentRound][tid] = duration;\n      setTimeout(() => {\n        nextTrial(tid + 1);\n      }, timeline.delayAfterKeyboard); \/\/ NaN|undef|negative behaves like 0 \n    }\n\n    function autoProceedCallback() {\n      if (!isAwaiting) return;\n      isAwaiting = false;\n      keyboardListener.callback = undefined;\n      nextTrial(tid + 1);\n    }\n  }\n\n\n  function runAdvancedTimeline(tid, pageId = 0) {\n    \/\/ End condition\n    if (pageId >= advancedTimeline.pages.length) {\n      nextTrial(tid + 1);\n      return;\n    }\n\n    const currentPage = advancedTimeline.pages[pageId];\n\n    \/\/ Page-level condition\n    if (!evaluatePageCondition(currentPage.condition)) {\n      runAdvancedTimeline(tid, pageId + 1);\n      return;\n    }\n\n    \/\/ Display\n    \/\/ \/\/ Content-level condition\n    \/\/ const conditionalDisplays = currentPage.displays.filter(display => {\n    \/\/   if (!display.condition) return true;\n    \/\/   const [conditionpageId, operation, conditionPools] = display.condition;\n    \/\/   const stepResponsePool = states.responsePools[currentRound][tid][conditionpageId];\n    \/\/   return conditionPools.includes(stepResponsePool);\n    \/\/ })\n    \/\/ console.log('conditionalDisplays', conditionalDisplays)\n\n    \/**\n     * @typedef DisplayDetail\n     * @property {Object} src\n     * @property {string[]} [bindKeyboard]\n     * @property {string} [swapToDisplayKey]\n     * @property {DisplayDetail} [swapTo]\n     *\/\n    \/**\n     * @typedef {Object.<string, DisplayDetail>} DisplayDetails\n     *\/\n\n    \/**  @type {DisplayDetails} This concentrates the info of page's displays and swaps *\/\n    const displayDetails = mapObject(currentPage.displays, src => ({ src }));\n    if (currentPage.swap) {\n      Object.entries(currentPage.swap).forEach(([swapFromDisplayKey, { bindKeyboard }]) => {\n        const swapToDisplayKey = currentPage.swapResult[tid][swapFromDisplayKey];\n        displayDetails[swapFromDisplayKey].bindKeyboard = bindKeyboard;\n        displayDetails[swapFromDisplayKey].swapToDisplayKey = swapToDisplayKey;\n        displayDetails[swapFromDisplayKey].swapTo = displayDetails[swapToDisplayKey];\n      })\n    }\n\n    \/\/ Page style\n    const containerInnerEl = thisQultricsQuestion.questionContainer.querySelector('.spt-trial-container-inner');\n    if (containerInnerEl) {\n      \/\/ Apply page style if exist, or apply (reset) overall style if exist\n      if (currentPage.style && typeof currentPage.style.containerTopBlank === 'number') {\n        containerInnerEl.style.paddingTop = currentPage.style.containerTopBlank + 'px';\n      } else {\n        containerInnerEl.style.paddingTop = '0px';\n      }\n    }\n\n    \/\/ Display\n    console.debug('displayDetails', displayDetails)\n    const stimuliItemsToDisplay = getATStimuliItemsToDisplay(displayDetails, poolUsage, currentPage.response, tid, pageId);\n    console.debug('stimuliItemsToDisplay', stimuliItemsToDisplay)\n    displayController.display(stimuliItemsToDisplay);\n\n    \/\/ Mouse Tracking\n    if (currentPage.mouseTracking) {\n      mouseTracker.start();\n    }\n\n    \/\/ Response\n    MixedListener(keyboardListener, mouseListener, currentPage.response, stimuliItemsToDisplay, function (response) {\n      if (currentPage.mouseTracking) {\n        const mouseTrackingData = mouseTracker.stop();\n        exportMouseTracking(mouseTrackingData, roundIndex, tid, pageId);\n      }\n\n      if (response[0] === 'keyboard') {\n        const responseKeyUnreversed = response[1].key;\n        \/\/ Reverse swap\n        \/\/ Given    | A1(x):pool1 | A2(y):pool2 | A3(z):pool3 | A4():empty |\n        \/\/ swaps to | A2    pool2 | A3    pool3 | A1    pool1 |      empty |\n        \/\/ If response is \"x\" -> it's A1 position swapped to display A2 -> revert to \"y\"\n        let responseKey = responseKeyUnreversed;\n        if (currentPage.swap) {\n          const responseDisplayDetail = Object.values(displayDetails).find(d => d.bindKeyboard && d.bindKeyboard.includes(responseKey));\n          if (responseDisplayDetail && responseDisplayDetail.swapTo && responseDisplayDetail.swapTo.bindKeyboard && responseDisplayDetail.swapTo.bindKeyboard[0]) { \/\/ better use ?.\n            responseKey = responseDisplayDetail.swapTo.bindKeyboard[0];\n          }\n        }\n        \/\/ Record response\n        states.responses[currentRound][tid][pageId] = responseKey;\n        states.responsesUnreversed[currentRound][tid][pageId] = responseKeyUnreversed;\n        states.responseDurations[currentRound][tid][pageId] = response[1].duration;\n\n      } else if (response[0] === 'timeout') {\n        states.responses[currentRound][tid][pageId] = 'TIMEOUT';\n\n      } else if (response[0] === 'mouseClick') {\n        const responseDisplayKeyUnreversed = response[1].key;\n        \/\/ Reverse swap\n        let responseDisplayKey = displayDetails[responseDisplayKeyUnreversed].swapToDisplayKey || responseDisplayKeyUnreversed;\n        \/\/ Record response\n        states.responses[currentRound][tid][pageId] = responseDisplayKey;\n        states.responsesUnreversed[currentRound][tid][pageId] = responseDisplayKeyUnreversed;\n        states.responseDurations[currentRound][tid][pageId] = response[1].duration;\n\n      } else {\n        alert('Sorry. Critical error occured in the survey webpage. Please restart survey or contact the survey conductor. Error message: \"Invalid participant response type: ' + response[0] + '\"');\n      }\n\n      setTimeout(() => runAdvancedTimeline(tid, pageId + 1), currentPage.interval || 0); \/\/ better use ?? here\n    });\n\n\n    \/**\n     * For now, only supports one \"response\" condition\n     *\/\n    function evaluatePageCondition(condition) {\n      if (!condition) return true;\n      if (condition[0] === 'response') {\n        const pageId = condition[1];\n        const comparisonOperator = condition[2];\n        const expectedResponses = condition[3];\n        const actualResponse = states.responses[currentRound][tid][pageId];\n        const isExpected = expectedResponses.includes(actualResponse);\n        return comparisonOperator === '==' ? isExpected : !isExpected;\n      } else if (condition[0] === 'poolSelection') {\n        const pageId = condition[1];\n        const key = condition[2];\n        const comparisonOperator = condition[3];\n        const expectedPools = condition[4];\n        const actualPool = states.advancedTimelinePoolSelection[currentRound][tid][pageId][key];\n        const isExpected = expectedPools.includes(actualPool);\n        return comparisonOperator === '==' ? isExpected : !isExpected;\n      } else if (condition[0] === 'and') {\n        return condition.slice(1).every(evaluatePageCondition);\n      } else if (condition[0] === 'or') {\n        return condition.slice(1).some(evaluatePageCondition);\n      } else {\n        return true;\n      }\n    }\n  }\n\n\n  \/**\n   * Start next trial if not ended. Update the response.\n   *\/\n  function nextTrial(newTid) {\n    exportResponse(newTid);\n    states.currentTrial = newTid;\n    if (states.currentTrial >= totalTrials) {\n      states.currentRound = roundIndex + 1;\n      states.currentTrial = undefined;\n      keyboardListener.callback = undefined;\n      thisQultricsQuestion.clickNextButton();\n    } else {\n      runTrial(newTid);\n    }\n  }\n\n  nextTrial(0);\n});\n\n\nQualtrics.SurveyEngine.addOnUnload(function () {\n  if (this.keyboardListener) {\n    this.keyboardListener.unmount();\n  }\n  if (this.mouseListener) {\n    this.mouseListener.unmount();\n  }\n});\n\n\nfunction exportResponse() {\n  const { responses, responsesUnreversed, responseDurations, responsePools, advancedTimelinePoolSelection } = states;\n  _set('sptResponses', joinResponses(responses));\n  _set('sptResponsesArray', JSON.stringify(responses));\n  _set('sptResponsesUnreversed', joinResponses(responsesUnreversed));\n  _set('sptResponsesUnreversedArray', JSON.stringify(responsesUnreversed));\n  _set('sptResponseDurations', joinResponses(responseDurations));\n  _set('sptResponseDurationsArray', JSON.stringify(responseDurations));\n  \/\/ _set('sptResponsePools', joinResponsePools(responsePools));\n  \/\/ _set('sptResponsePoolsArray', JSON.stringify(responsePools));\n  if (advancedTimelinePoolSelection) {\n    _set('sptPoolSelectionArray', transformPoolSelection(advancedTimelinePoolSelection));\n  }\n\n  \/** Join adaptively by timeline\/logical *\/\n  function joinResponses(responses) {\n    return responses.map(round => round.map(trial => Array.isArray(trial) ? trial.join('.') : trial).join(',')).join(';');  \/\/ empty array item will be empty string\n  }\n  function joinResponsePools(responsePools) {\n    return responsePools.map(round => round.map(trial => trial.map(step => typeof step === 'number' ? step + 1 : null).join('.')).join(',')).join(';');\n  }\n  \/** Make pool index 1-based *\/\n  function transformPoolSelection(poolSelection) {\n    return JSON.stringify(poolSelection.map(round => round.map(trial=> trial.map(page => mapObject(page, poolIndex => poolIndex + 1)))));\n  }\n}\n\nfunction exportMouseTracking(mouseTrackingData, rid, tid, pid) {\n  _set('spt_MT_x_r=' + (rid + 1) + '_t=' + (tid + 1) + '_p=' + (pid + 1), mouseTrackingData.x.join(','));\n  _set('spt_MT_y_r=' + (rid + 1) + '_t=' + (tid + 1) + '_p=' + (pid + 1), mouseTrackingData.y.join(','));\n  _set('spt_MT_t_r=' + (rid + 1) + '_t=' + (tid + 1) + '_p=' + (pid + 1), mouseTrackingData.t.map(x => x.toFixed(3)).join(','));\n}\n\n\/**\n * Get content from stimuli or preload\n * @param {number|null} poolIndex \n * @param {number} shuffledItemIndex \n * @returns {StimuliItemToDisplay}\n *\/\nfunction getContent(poolIndex, shuffledItemIndex) {\n  if (poolIndex === null) return null;\n  if (poolIndex < 0 || shuffledItemIndex >= pools[poolIndex].shuffledIndexes) { \/\/ Formally, poolIndex of -1 (which is 0 in 1-based config) means empty\n    return { type: 'empty', content: '' };\n  }\n  const itemIndex = pools[poolIndex].shuffledIndexes[shuffledItemIndex];\n  const item = pools[poolIndex].items[itemIndex];\n  if (item === undefined) {\n    return null;\n  }\n  const { type, content } = item;\n  const preload = type === 'image' && myGlobalThis.preload && myGlobalThis.preload[content];\n  return { type, content: preload || content }; \/\/ better use ?? here\n}\n\n\/**\n * @typedef {{key: string, stimuliItem: StimuliItemToDisplay, accuratePoint?: boolean}[]} StimuliItemsToDisplay\n *\/\n\n\n\/**\n * @param {{key: string, pool: number|null}[]} frame \n * @param {number[]} poolUsage\n * @returns {StimuliItemsToDisplay}\n *\/\nfunction getStimuliItemsToDisplay(frame, poolUsage) {\n  return frame.map(({ key, pool }) => {\n    let stimuliItem = null;\n    if (typeof pool === 'number' && pool >= 0) {\n      stimuliItem = getContent(pool, poolUsage[pool]);\n      poolUsage[pool]++;\n    } else if (pool === -1) {\n      stimuliItem = { type: 'empty', content: '' };\n    }\n    return { key, stimuliItem };\n  });\n}\n\nif (advancedTimeline) {\n  \/\/ [roundIndex][pageIndex][displayKey] -> StimuliItemToDisplay\n  if (states.advancedTimelineDisplayHistory === undefined) {\n    states.advancedTimelineDisplayHistory = ndArrayOf(\n      [states.params.rounds.length, advancedTimeline.pages.length],\n      () => ({})\n    );\n  }\n  \/\/ [roundIndex][trialIndex][pageIndex][displayKey] -> poolIndex\n  if (states.advancedTimelinePoolSelection === undefined) {\n    states.advancedTimelinePoolSelection = ndArrayOf(\n      [states.params.rounds.length, totalTrials, advancedTimeline.pages.length],\n      () => ({})\n    );\n  }\n}\n\n\/**\n * @param {DisplayDetails} displayDetails \n * @param {number[]} poolUsage\n * @param {} responseConfigs advanceTimeline.pages[*].response\n * @param {number} pageIndex\n * @returns {StimuliItemsToDisplay}\n *\/\nfunction getATStimuliItemsToDisplay(displayDetails, poolUsage, responseConfigs, tid, pageIndex) {\n  return Object.entries(displayDetails).map(([key, displayDetail]) => {\n    const src = displayDetail.swapTo ? displayDetail.swapTo.src : displayDetail.src;\n    let stimuliItem = null;\n    if (src[0] === 'pool') {\n      \/\/ If pool already determined from the other iframe, use it\n      let pool = states.advancedTimelinePoolSelection[states.currentRound][tid][pageIndex][key];\n      \/\/ Else, determine now\n      if (typeof determinedPool !== 'number') {\n        const possiblePools = src[1];\n        pool = randomChoice(possiblePools);\n        states.advancedTimelinePoolSelection[states.currentRound][tid][pageIndex][key] = pool;\n      }\n      stimuliItem = getContent(pool, poolUsage[pool]++);\n    } else if (src[0] === 'copy') {\n      stimuliItem = states.advancedTimelineDisplayHistory[states.currentRound][src[1]][src[2]];\n    } else if (src[0] === 'blank') {\n      stimuliItem = { type: 'empty', content: '' };\n    }\n    states.advancedTimelineDisplayHistory[states.currentRound][pageIndex][key] = stimuliItem;\n    const accuratePoint = responseConfigs && responseConfigs.mouseClick && responseConfigs.mouseClick[key] && responseConfigs.mouseClick[key].accuratePoint;\n    return { key, stimuliItem, accuratePoint };\n  });\n}\n\n\n\/**\n * @typedef {{ keys: string[], delayBefore?: number, delayAfter?: number }} KeyboardResponse\n * @typedef {{ duration: number }} TimeoutResponse\n * @typedef {{ [key: string]: { accuratePoint?: boolean }}} MouseClickResponse\n * @param {{ keyboard?: KeyboardResponse, timeout?: TimeoutResponse, mouseClick?: MouseClickResponse }} responseConfigs\n * @param {StimuliItemsToDisplay} stimuliItemsToDisplay\n * @param {(response: ['keyboard', { key: string, duration: number }] | ['timeout'] | ['mouseClick', { key: string, duration: number }]) -> void} callback\n *\/\nfunction MixedListener(keyboardListener, mouseListener, responseConfigs, stimuliItemsToDisplay, callback) {\n  console.debug('MixedListener', responseConfigs)\n  let isAwaiting = true;\n\n  if (responseConfigs.keyboard) {\n    let keyboardStartTime;\n    keyboardListener.acceptedKeys = responseConfigs.keyboard.keys;\n    setTimeout(() => {\n      isAwaiting = true;\n      keyboardListener.callback = keyboardListenerCallback;\n      keyboardStartTime = performance.now();\n    }, responseConfigs.keyboard.delayBefore || 0);\n    function keyboardListenerCallback(key) {\n      if (!isAwaiting) return;\n      stopAwaiting();\n      const duration = performance.now() - keyboardStartTime;\n      setTimeout(() => {\n        callback(['keyboard', { key, duration }])\n      }, responseConfigs.keyboard.delayAfter || 0);\n    }\n  }\n\n  if (responseConfigs.timeout) {\n    function timeoutCallback() {\n      if (!isAwaiting) return;\n      stopAwaiting();\n      callback(['timeout']);\n    }\n    setTimeout(timeoutCallback, responseConfigs.timeout.duration);\n  }\n\n  if (typeof responseConfigs.mouseClick === 'object') {\n    const mouseListenerConfig = mapObject(responseConfigs.mouseClick, (({ accuratePoint }, key) => {\n      const isButton = stimuliItemsToDisplay.find(i => i.key === key && i.stimuliItem.type === 'button');\n      return { key, isButton, accuratePoint };\n    }));\n    const mouseClickStartTime = performance.now();\n    mouseListener.callback = function (key) {\n      if (!isAwaiting) return;\n      stopAwaiting();\n      const duration = performance.now() - mouseClickStartTime;\n      callback(['mouseClick', { key, duration }]);\n    };\n    mouseListener.listen(mouseListenerConfig);\n  }\n\n  function stopAwaiting() {\n    isAwaiting = false;\n    keyboardListener.acceptedKeys = [];\n    keyboardListener.callback = undefined;\n    mouseListener.unlisten();\n    mouseListener.callback = undefined;\n  }\n}\n\n\n\/**\n * @param {HTMLElement} questionContainer \n *\/\nfunction DisplayController(questionContainer) {\n  \/**\n   * @param {StimuliItemsToDisplay} stimuliItems\n   *\/\n  function display(stimuliItems) {\n    console.debug('DisplayController display', stimuliItems);\n    clear();\n    stimuliItems.forEach(({ key, stimuliItem, accuratePoint }) => {\n      const contentEl = questionContainer.querySelector('.spt-trial-content.spt-trial-content-' + key);\n      if (contentEl && stimuliItem !== null) {\n        if (stimuliItem.type === 'text') {\n          const textEl = contentEl.querySelector('.spt-trial-text');\n          if (textEl) {\n            textEl.innerHTML = stimuliItem.content;\n            textEl.style.display = '';\n          }\n        } else if (stimuliItem.type === 'image') {\n          const imageEl = contentEl.querySelector('.spt-trial-image');\n          if (imageEl) {\n            imageEl.src = stimuliItem.content;\n            imageEl.style.display = '';\n          }\n        } else if (stimuliItem.type === 'button') {\n          const buttonEl = contentEl.querySelector('.spt-trial-button');\n          if (buttonEl) {\n            buttonEl.innerHTML = stimuliItem.content || ' '; \/\/ at least show button outline\n            buttonEl.style.display = '';\n          }\n        }\n        if (accuratePoint) {\n          const accuratePointEl = contentEl.querySelector('.spt-trial-accurate-point');\n          if (accuratePointEl) {\n            accuratePointEl.style.display = '';\n          }\n        }\n        contentEl.style.display = 'flex';\n      }\n    });\n  }\n  function clear() {\n    questionContainer.querySelectorAll('.spt-trial-content').forEach(contentEl => {\n      const textEl = contentEl.querySelector('.spt-trial-text');\n      if (textEl) {\n        textEl.style.display = 'none';\n        textEl.innerHTML = '';\n      }\n      const imageEl = contentEl.querySelector('.spt-trial-image');\n      if (imageEl) {\n        imageEl.style.display = 'none';\n        imageEl.src = '';\n      }\n      const buttonEl = contentEl.querySelector('.spt-trial-button');\n      if (buttonEl) {\n        buttonEl.style.display = 'none';\n        buttonEl.innerHTML = '';\n      }\n      const accuratePointEl = contentEl.querySelector('.spt-trial-accurate-point');\n      if (accuratePointEl) {\n        accuratePointEl.style.display = 'none';\n      }\n      contentEl.style.display = 'none';\n    });\n  }\n  clear();\n  return { display, clear };\n}\n\n\n\nfunction MouseTracker() {\n  let lastX, lastY; \/\/ for xy when start\n  let historyX, historyY, historyT; \/\/ when defined, constantly push to here\n\n  function postMessageOnMouseMove(event) {\n    event.stopPropagation();\n    event.preventDefault();\n    window.top.postMessage({\n      type: 'iframe-mousemove',\n      screenX: event.screenX,\n      screenY: event.screenY,\n    });\n  }\n  \/** @param {MouseEvent} e.data *\/\n  function handleMouseMoveMessage(e) {\n    if (e.data.type === 'iframe-mousemove') {\n      lastX = e.data.screenX;\n      lastY = e.data.screenY;\n      historyX && historyX.push(e.data.screenX);\n      historyY && historyY.push(e.data.screenY);\n      historyT && historyT.push(performance.now());\n      \/\/ historyT && console.debug('handleMouseMoveMessage record', historyT.join())\n    }\n  }\n  function mount() {\n    window.addEventListener('mousemove', postMessageOnMouseMove);\n    window.top.addEventListener('message', handleMouseMoveMessage);\n  }\n  function unmount() {\n    window.removeEventListener('mousemove', postMessageOnMouseMove);\n    window.top.removeEventListener('message', handleMouseMoveMessage);\n  }\n  function start() {\n    if (lastX !== undefined && lastY !== undefined) {\n      historyX = [lastX];\n      historyY = [lastY];\n      historyT = [performance.now()];\n    } else {\n      historyX = [];\n      historyY = [];\n      historyT = [];\n    }\n  }\n  function stop() {\n    const result = {\n      x: historyX && historyX.slice(),\n      y: historyY && historyY.slice(),\n      t: historyT && historyT.map(t => t - historyT[0]), \/\/ safe even if historyT===[]\n    };\n    historyX = undefined;\n    historyY = undefined;\n    historyT = undefined;\n    return result;\n  }\n  return { mount, unmount, start, stop };\n}\n\n\n\/\/ Dark mode\nif (states.params.darkMode) {\n  let wrapperEl, skinInnerEl;\n  let wrapperElOriginalColor, skinInnerElOriginalColor;\n\n  Qualtrics.SurveyEngine.addOnload(function () {\n    wrapperEl = document.getElementById('Wrapper');\n    if (wrapperEl) {\n      wrapperElOriginalColor = wrapperEl.style.backgroundColor;\n      wrapperEl.style.backgroundColor = 'black';\n      skinInnerEl = wrapperEl.getElementsByClassName('SkinInner').length ? wrapperEl.getElementsByClassName('SkinInner')[0] : null;\n      if (skinInnerEl) {\n        skinInnerElOriginalColor = skinInnerEl.style.backgroundColor;\n        skinInnerEl.style.backgroundColor = 'black';\n      }\n    }\n  });\n\n  Qualtrics.SurveyEngine.addOnUnload(function () {\n    if (wrapperEl) {\n      wrapperEl.style.backgroundColor = wrapperElOriginalColor;\n      if (skinInnerEl) {\n        skinInnerEl.style.backgroundColor = skinInnerElOriginalColor;\n      }\n    }\n  });\n}\n\n\n\nfunction sum(array) {\n  return array.reduce((a, b) => a + b, 0);\n}\n\nfunction _set(name, value) {\n  const nameWithIdentifier = sptSurveyIdentifier ? name + ':' + sptSurveyIdentifier : name;\n  console.debug('[AMP] set ' + nameWithIdentifier + ' = ' + value);\n  Qualtrics.SurveyEngine.setEmbeddedData(nameWithIdentifier, value);\n}\n\n\/**\n * @template K, V, W\n * @param {Record.<K, V>} obj \n * @param {function(V, K): W} mapper \n * @returns {Record.<K, W>}\n *\/\nfunction mapObject(obj, mapper) {\n  return Object.fromEntries(Object.entries(obj).map(([key, value]) => [key, mapper(value, key)]));\n}\n\nfunction deepClone(item) {\n  if (Array.isArray(item)) {\n    return item.map(deepClone);\n  }\n  if (item instanceof Object) {\n    const clone = {};\n    Object.keys(item).forEach(key => {\n      clone[key] = deepClone(item[key]);\n    });\n    return clone;\n  }\n  return item;\n}\n\nfunction randomInt(x) {\n  return Math.floor(Math.random() * x);\n}\n\nfunction randomChoice(arr) {\n  return arr[randomInt(arr.length)];\n}\n\nfunction ndArrayOf(dim, genItem = () => undefined) {\n  if (dim.length === 0) {\n    return genItem();\n  }\n  return Array(dim[0]).fill().map(() => ndArrayOf(dim.slice(1), genItem));\n}",
        "DataVisibility": {
          "Private": false,
          "Hidden": false
        }
      }
    },
    {
      "SurveyID": "SV_dnAkDKOddKsPTpQ",
      "Element": "QG",
      "PrimaryAttribute": "QG_FH8Cdf0L5gg9uBa",
      "SecondaryAttribute": "Default Quota Group",
      "TertiaryAttribute": null,
      "Payload": {
        "ID": "QG_FH8Cdf0L5gg9uBa",
        "Name": "Default Quota Group",
        "Selected": true,
        "MultipleMatch": "PlaceInAll",
        "Public": false,
        "Quotas": []
      }
    },
    {
      "SurveyID": "SV_dnAkDKOddKsPTpQ",
      "Element": "RS",
      "PrimaryAttribute": "RS_6zXdxkXXWoWLKL4",
      "SecondaryAttribute": "Default Response Set",
      "TertiaryAttribute": null,
      "Payload": null
    },
    {
      "SurveyID": "SV_dnAkDKOddKsPTpQ",
      "Element": "SQ",
      "PrimaryAttribute": "QID1",
      "SecondaryAttribute": "This loads parameters. And it hides \"next\" button until all trial images are loaded.",
      "TertiaryAttribute": null,
      "Payload": {
        "QuestionText": "This loads parameters. And&nbsp;it hides \"next\" button until all trial images are loaded.",
        "DefaultChoices": false,
        "DataExportTag": "LoadParameters",
        "QuestionID": "QID1",
        "QuestionType": "DB",
        "Selector": "TB",
        "DataVisibility": {
          "Private": false,
          "Hidden": false
        },
        "Configuration": {
          "QuestionDescriptionOption": "UseText"
        },
        "QuestionDescription": "This loads parameters. And it hides \"next\" button until all trial images are loaded.",
        "ChoiceOrder": [],
        "Validation": {
          "Settings": {
            "Type": "None"
          }
        },
        "GradingData": [],
        "Language": [],
        "NextChoiceId": 4,
        "NextAnswerId": 1,
        "QuestionJS": "const myGlobalThis = window.top;\nmyGlobalThis.qs = Qualtrics.SurveyEngine; \/\/ for debug\nconst sptSurveyIdentifier = Qualtrics.SurveyEngine.getEmbeddedData('sptSurveyIdentifier');\nconsole.log('[SPT] sptSurveyIdentifier: ' + sptSurveyIdentifier);\nif (myGlobalThis.sptStates === undefined) {\n  myGlobalThis.sptStates = {};\n}\nconst states = {};\nif (sptSurveyIdentifier) {\n  myGlobalThis.sptStates[sptSurveyIdentifier] = states;\n} else {\n  myGlobalThis.sptStates = states;\n}\n\/\/ in case SurveyID is unavailable, ensure no-ref survey could run\n\nfunction main() {\n  const params = loadParams();\n  states.params = params;\n  states.currentRound = 0;\n  console.log('[SPT] Loaded parameters', states.params);\n\n  applyPrime(params);\n  applyShuffle(params);\n  applyPreload(params);\n  try {\n    applyAdvancedTimelineSwap(params);\n  } catch (e) {\n    console.error('applyAdvancedTimelineSwap', e)\n  }\n  console.log('[SPT] Processed parameters', states.params);\n}\n\nQualtrics.SurveyEngine.addOnload(main);\n\n\/**\n * @typedef {import('.\/type.d.ts').StimuliItem} StimuliItem\n * @typedef {import('.\/type.d.ts').StimuliPoolConfig} StimuliPoolConfig\n * @typedef {import('.\/type.d.ts').Timeline} Timeline\n * @typedef {import('.\/type.d.ts').StimuliRound} StimuliRound\n * @typedef {import('.\/type.d.ts').StimuliItemRef} StimuliItemRef\n * @typedef {import('.\/type.d.ts').StimuliPrimeItem} StimuliPrimeItem\n * @typedef {import('.\/type.d.ts').Params} Params\n *\/\n\n\/**\n * @returns {Params}\n *\/\nfunction loadParams() {\n  try {\n    const stimuliItems = JSON.parse(_('stimuliItems'));\n    const timeline = _parse('timeline');\n    const totalRounds = _parse('totalRounds', 1);\n    if (timeline.advanced) {\n      transformAdvancedTimeline(timeline);\n    } else {\n      transformConcurrentPools(timeline, stimuliItems[0].pools.length);\n    }\n    return {\n      rounds: Array(totalRounds).fill().map(() => {\n        const clone = deepClone(stimuliItems[0]);\n        if (timeline.advanced) {\n          clone.advancedTimeline = deepClone(timeline);\n        } else {\n          clone.timeline = deepClone(timeline);\n        }\n        return clone;\n      }), \/\/ for now, use same timeline and stimuli for all rounds\n      totalRounds,\n      primes: JSON.parse(_('primes')),\n      acceptedKeys: (_('acceptedKeys') || '').split(','),\n      darkMode: _parse('darkMode', false),\n    };\n  } catch (e) {\n    console.error(e);\n    alert('Error when loading parameters. Error message:\\n ' + e.toString());\n    throw e;\n  }\n}\n\n\n\n\n\/**\n * Save shuffle result in `rounds[*].pools[*].shuffledIndexes`\n * @param {Params} params \n *\/\nfunction applyShuffle(params) {\n  const shuffleResult = params.rounds.map(round => (\n    round.pools.map(pool => {\n      pool.shuffledIndexes = shuffledIndexes(pool);\n      return pool.shuffledIndexes.map(x => x + 1).join(','); \/\/ to 1-based\n    }).join(';')\n  )).join('\/');\n  _set('shuffleResult', shuffleResult);\n  outputEachShuffledResult(params.rounds);\n}\n\n\/**\n * @param {StimuliPoolConfig} pool  \n * @returns {number[]}\n *\/\nfunction shuffledIndexes(pool) {\n  const { items, shuffle } = pool;\n  const indexes = getIndexesRepresentation(items);\n\n  if (shuffle >= 1) {\n    shuffleWithMaxRepeat(indexes, shuffle);\n  } else if (shuffle) {\n    shuffleArray(indexes);\n  }\n  return indexes;\n\n  \/**\n   * Represent pool with indexes rather than the actual content, rotationally\n   * e.g. [{count:2},{count:3},{count:1}] -> [0,1,2,0,1,1]\n   * @param {{count: number}[]} items \n   * @returns {number[]}\n   *\/\n  function getIndexesRepresentation(items) {\n    const result = [];\n    const maxCount = items.map(x => x.count).reduce((x, y) => Math.max(x, y), 0);\n    for (let numOfRotations = 0; numOfRotations < maxCount; numOfRotations++) {\n      items.forEach(({ count }, index) => {\n        if (count > numOfRotations) {\n          result.push(index);\n        }\n      })\n    }\n    return result;\n  }\n}\n\n\n\/\/ Shuffles \"array\" in-place\nfunction shuffleArray(array) {\n  for (let i = array.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    const temp = array[i];\n    array[i] = array[j];\n    array[j] = temp;\n  }\n  return array;\n}\n\n\/\/ Shuffles \"array\" in-place, with promise that no item will repeat \"maxRepeat\" times consecutively\nfunction shuffleWithMaxRepeat(array, maxRepeat) {\n  const MAX_TRY = 100; \/\/ if cannot satisfy after too many tries, stop shuffling and ignore maxRepeat\n  const validate = () => {\n    let repeatItem, repeatTimes;\n    for (let i of array) {\n      if (i === repeatItem) {\n        if (repeatTimes === maxRepeat) {\n          return false;\n        } else {\n          repeatTimes++;\n        }\n      } else {\n        repeatItem = i;\n        repeatTimes = 1;\n      }\n    }\n    return true;\n  }\n  for (let i = 0; i < MAX_TRY; i++) {\n    shuffleArray(array);\n    if (validate()) return;\n  }\n}\n\n\n\/**\n * \n * @param {StimuliRound[]} rounds \n *\/\nfunction outputEachShuffledResult(rounds) {\n  rounds.forEach((round, roundIndex) => {\n    round.pools.forEach((pool, poolIndex) => {\n      pool.shuffledIndexes.forEach((shuffleResult, shuffleResultIndex) => {\n        _set('shuffled_' + (roundIndex + 1) + '_' + (poolIndex + 1) + '_' + (shuffleResultIndex + 1) + '_item_index', shuffleResult + 1, true);\n        _set('shuffled_' + (roundIndex + 1) + '_' + (poolIndex + 1) + '_' + (shuffleResultIndex + 1) + '_content', pool.items[shuffleResult].content, true);\n        _set('shuffled_' + (roundIndex + 1) + '_' + (poolIndex + 1) + '_' + (shuffleResultIndex + 1) + '_type', pool.items[shuffleResult].type, true);\n      });\n    });\n  });\n}\n\n\n\/**\n * @param {Params} params\n *\/\nfunction applyPrime(params) {\n  const primeResult = findPrime(params.primes, params.rounds);\n  applyAndOutputPrime(params, primeResult);\n}\n\n\/** \n * @typedef {{primeName: string, itemIndex: number|null}[]} PrimeResult \n * itemIndex: 0-based, null means not found\n *\/\n\/**\n * Get locators for primes\n * @param {StimuliPrimeItem[]} primes\n * @param {StimuliRound[]} rounds\n * @returns {PrimeResult}\n *\/\nfunction findPrime(primes, rounds) {\n  if (primes === null) {\n    return {};\n  }\n  \/** @type {PrimeResult} *\/\n  const primeResult = [];\n  for (const { name, pool, include, exclude } of primes) {\n    const includeIndexes = include && include.length ? (\n      getItemIndex(include, primeResult)\n    ) : (\n      range(rounds[0].pools[pool - 1].items.length) \/\/ no item means include all in pool (for now, all rounds share same stimuli)\n    );\n    const excludeIndexes = getItemIndex(exclude || [], primeResult);\n    const includeExcludeIndexes = includeExclude(includeIndexes, excludeIndexes);\n    const itemIndex = randomChoice(includeExcludeIndexes);\n    console.debug('prime include exclude', includeIndexes, excludeIndexes, '->', includeExcludeIndexes, '->', itemIndex);\n    primeResult.push({ primeName: name, itemIndex });\n  }\n  console.debug('primeResult', primeResult);\n  return primeResult;\n\n  \/**\n   * @param {StimuliItemRef[]} itemRefs\n   * @param {PrimeResult} primeResult \n   * @returns {number | null}\n   *\/\n  function getItemIndex(itemRefs, primeResult) {\n    \/\/ (string (prime name) | itemIndexes)[]\n    return itemRefs.map(ref => {\n      if (typeof ref === 'string') {\n        const found = primeResult.find(({ primeName }) => primeName === ref);\n        return found ? found.itemIndex : null;\n      } else {\n        return ref - 1;\n      }\n    }).filter(x => x !== null);\n  }\n\n  function includeExclude(include, exclude) {\n    const includeDedupe = [];\n    for (const x of include) {\n      if (!includeDedupe.includes(x)) {\n        includeDedupe.push(x);\n      }\n    }\n    return includeDedupe.filter(x => !exclude.includes(x));\n  }\n\n  function randomChoice(list) {\n    return list.length ? list[Math.floor(Math.random() * list.length)] : null;\n  }\n}\n\n\/**\n * @param {Params} params\n * @param {PrimeResult} primeResult\n *\/\nfunction applyAndOutputPrime(params, primeResult) {\n  _set('primeResult', primeResult.map(({ primeName, itemIndex }) => primeName + '=' + (itemIndex + 1)).join(';'));\n  _set('primeResultJson', JSON.stringify(Object.fromEntries(primeResult.map(({ primeName, itemIndex }) => [primeName, itemIndex + 1]))));\n\n  for (const { primeName, itemIndex } of primeResult) {\n    if (itemIndex !== null) {\n      const prime = params.primes.find(p => p.name === primeName);\n      if (typeof prime === 'object' && prime !== null) {\n        const poolIndex = prime.pool - 1;\n        \/\/ Apply stimuli count override\n        if (typeof prime === 'object' && prime !== null && typeof prime.overrideCount === 'number') { \/\/ override same for all rounds\n          params.rounds.forEach(round => {\n            round.pools[poolIndex].items[itemIndex].count = prime.overrideCount;\n          });\n        }\n        if (typeof prime === 'object' && prime !== null && Array.isArray(prime.overrideCount)) { \/\/ override differently for each round\n          prime.overrideCount.forEach((roundOverrideCount, roundIndex) => {\n            if (typeof roundOverrideCount === 'number') {\n              params.rounds[roundIndex].pools[poolIndex].items[itemIndex].count = roundOverrideCount;\n            }\n          });\n        }\n\n        const stimuliItem0 = params.rounds[0].pools[poolIndex].items[itemIndex];\n        _set('prime_' + primeName + '_item_index', itemIndex + 1);\n        _set('prime_' + primeName + '_type', stimuliItem0.type);\n        _set('prime_' + primeName + '_content', stimuliItem0.content);\n        continue;\n      }\n    }\n    _set('prime_' + primeName + '_item_index', 'null');\n    _set('prime_' + primeName + '_type', 'null');\n    _set('prime_' + primeName + '_content', 'null');\n  }\n}\n\n\n\n\/**\n * Transform the pool number from 1-indexed to 0-indexed in place. \n * Value \"0\" becomes \"-1\" means display blank.\n * Generate dummy concurrentPool if not specified.\n * @param {Timeline} timeline\n * @param {number} numOfPools\n *\/\nfunction transformConcurrentPools(timeline, numOfPools) {\n  if (timeline.concurrentDisplays) {\n    timeline.concurrentDisplays.forEach(frame => {\n      for (keyPoolMapping of frame) {\n        if (typeof keyPoolMapping.pool === 'number') {\n          keyPoolMapping.pool -= 1;\n        }\n      }\n    });\n  } else {\n    \/\/ default: use \"1\" as element key, return [[{key:\"1\", pool:0}], [{key:\"1\", pool:1}], [{key:\"1\", pool:2}] ...]\n    timeline.concurrentDisplays = range(numOfPools).map(i => [{ key: 'A1', pool: i }]);\n  }\n}\n\n\n\/**\n * Make poolIndex, pageIndex, flagIndex in advancedTimeline 0-indexed\n *\/\nfunction transformAdvancedTimeline(advancedTimeline) {\n  if (!advancedTimeline) return;\n  for (const page of advancedTimeline.pages) {\n    transformAdvancedTimelineCondition(page.condition);\n    for (const displayKey in page.displays) {\n      const displayItem = page.displays[displayKey];\n      if (displayItem[0] === 'pool') {\n        displayItem[1] = displayItem[1].map(x => x - 1); \/\/ poolIndex\n      } else if (displayItem[0] === 'copy') {\n        displayItem[1] -= 1; \/\/ pageIndex\n      }\n    }\n  }\n}\n\nfunction transformAdvancedTimelineCondition(condition) {\n  if (!Array.isArray(condition)) return;\n  if (condition[0] === 'and' || condition[0] === 'or') {\n    for (let i = 1; i < condition.length; i++) {\n      transformAdvancedTimelineCondition(condition[i]);\n    }\n  } else if (condition[0] === 'response') {\n    condition[1] -= 1; \/\/ pageIndex\n  } else if (condition[0] === 'poolSelection') {\n    condition[1] -= 1; \/\/ pageIndex\n    condition[4] = condition[4].map(x => x - 1); \/\/ poolIndex\n  }\n}\n\n\/**\n * Save swap result in `rounds[*].advancedTimeline.page[*].swapResult`\n * as `swapResult[trialId] = { swapFromKey: swapToKey }`\n * @param {Params} params \n *\/\nfunction applyAdvancedTimelineSwap(params) {\n  const resultsToExport = [];\n  params.rounds.forEach((round, roundIndex) => {\n    if (round.advancedTimeline) {\n      round.advancedTimeline.pages.forEach((page, pageIndex) => {\n        if (page.swap) {\n          console.debug('advancedTimeline.page.swap', roundIndex, pageIndex)\n          \/\/ Generate $totalTrials count of shuffled $displayKey[]\n          const displayKeysToSwap = Object.keys(page.swap); \/\/ swapFrom\n          page.swapResult = range(round.totalTrials).map(() => { \/\/ for each trail\n            const swappedDisplayKeys = shuffleArray(deepClone(displayKeysToSwap)); \/\/ swapTo\n            return Object.fromEntries(zip(displayKeysToSwap, swappedDisplayKeys));\n          });\n          console.debug('page.swapResult', page.swapResult)\n          resultsToExport.push({ roundIndex: roundIndex + 1, pageIndex: pageIndex + 1, swapResult: page.swapResult })\n        }\n      });\n    }\n  });\n  \/\/ Export \n  _set('advancedTimelineSwapResult', JSON.stringify(resultsToExport));\n}\n\n\n\/**\n * Preload images. Return a copy of the array but the items will be replaced with preloaded blobs asynchronously.\n * Preloaded images are stored in object `myGlobalThis.preload`\n * (We cannot directly use http cache to preload image, because Qualtrics sets the cache to expire in 60s (`cache-control: max-age=60`))\n * (Thus, use blobs.)\n * globalThis.preload object values:\n *   undefined := loading; null = error; string (blob url) = success\n * @param {Params} params\n * @returns {void}\n *\/\nfunction applyPreload(params) {\n  if (myGlobalThis.preload === undefined) {\n    myGlobalThis.preload = {};\n  }\n  const imageContents = dedupe(\n    params.rounds.flatMap(({ pools }) =>\n      pools.flatMap(({ items }) =>\n        items.map(item => item.type === 'image' ? item.content : null).filter(x => x !== null)\n      )\n    )\n  );\n  for (const content of imageContents) {\n    myGlobalThis.preload[content] = undefined;\n    \/\/ (even if already preloaded, do not skip; otherwise blob expire when restart survey in preview)\n    \/\/ if content starts with 'http(s):\/\/'\n    \/\/ if (\/^https?:\\\/\\\/\/.test(content)) {\n    retry(function () {\n      createImageBlob(content, (e, blob) => {\n        if (blob) {\n          myGlobalThis.preload[content] = blob;\n          console.debug('Preload blob created:', blob);\n        } else {\n          myGlobalThis.preload[content] = null;\n          console.debug('Preload blob error:', e);\n        }\n      });\n    });\n    \/\/ } else {\n    \/\/   console.debug('Preload skipped for non-url content:', content)\n    \/\/ }\n  };\n\n  function createImageBlob(url, callback) {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.responseType = 'blob';\n    xhr.onload = function () {\n      if (this.status === 200 || this.status === 304) {\n        callback(null, URL.createObjectURL(this.response));\n      } else {\n        callback(new Error('Request failed with status ' + this.status));\n      }\n    };\n    xhr.onerror = function () {\n      callback(new Error('Network error'));\n    };\n    xhr.send();\n  }\n}\n\n\/**\n * @param {string} name \n * @returns {string|null}\n *\/\nfunction _(name) {\n  return Qualtrics.SurveyEngine.getEmbeddedData(sptSurveyIdentifier ? name + ':' + sptSurveyIdentifier : name);\n}\n\n\/**\n * Get embedded data as object, use default value if not exist. Similar to Python dict.get()\n * Throw exception when parse error.\n * @param {string} name \n * @param {any} [defaultValue=null]\n * @returns {any}\n *\/\nfunction _parse(name, defaultValue = null) {\n  const stringData = _(name);\n  if (stringData === null) {\n    return defaultValue;\n  } else {\n    return JSON.parse(stringData);\n  }\n}\n\nfunction _set(name, value, debugLevel) {\n  const nameWithIdentifier = sptSurveyIdentifier ? name + ':' + sptSurveyIdentifier : name;\n  const logStr = '[SPT] set ' + nameWithIdentifier + ' = ' + value;\n  debugLevel ? console.debug(logStr) : console.log(logStr);\n  Qualtrics.SurveyEngine.setEmbeddedData(nameWithIdentifier, value);\n}\n\n\n\/**\n * @deprecated\n * @template K, V, W\n * @param {Record.<K, V>} obj \n * @param {function(V): W} mapper \n * @returns {Record.<K, W>}\n *\/\nfunction mapObject(obj, mapper) {\n  return Object.fromEntries(Object.entries(obj).map(([key, value]) => [key, mapper(value)]));\n}\n\n\nfunction range(n) {\n  return Array(n).fill().map((_, index) => index);\n}\n\n\nfunction deepClone(item) {\n  if (Array.isArray(item)) {\n    return item.map(deepClone);\n  }\n  if (item instanceof Object) {\n    const clone = {};\n    Object.keys(item).forEach(key => {\n      clone[key] = deepClone(item[key]);\n    });\n    return clone;\n  }\n  return item;\n}\n\n\nfunction retry(operation, times = 5) {\n  try {\n    operation();\n  } catch (e) {\n    if (times > 1) {\n      retry(operation, times - 1);\n    } else {\n      throw e;\n    }\n  }\n}\n\n\n\/** \n * @param {Array} array  \n * @returns {Array}\n * *\/\nfunction dedupe(array) {\n  return array.reduce((prev, curr) => {\n    if (!prev.includes(curr)) {\n      prev.push(curr);\n    }\n    return prev;\n  }, [])\n}\n\n\nfunction zip(a, b) {\n  return a.map((k, i) => [k, b[i]]);\n}"
      }
    }
  ]
}